use std::{io::{Error, ErrorKind, Read}, marker::PhantomData};

use serde::{Deserialize, Serialize, de::{SeqAccess, Visitor}};
use nbt::{Blob, de::Decoder, ser::Encoder};

/// Gamemode type
#[repr(i8)]
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum Gamemode {
    /// If no previous gamemode exists
    NoPreviousMode = -1,
    /// Survival mode
    Survival = 0,
    /// Creative mode
    Creative = 1,
    /// Adventure mode
    Adventure = 2,
    /// Spectator mode
    Spectator = 3,
}

/// LevelType type
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq)]
pub enum LevelType {
    /// default world
    Default,
    /// flat world
    Flat,
    /// largeBiomes world
    LargeBiomes,
    /// amplified world
    Amplified,
    /// customized world
    Customized,
    /// buffet world
    Buffet,
    /// default_1_1 world
    Default11,
}

/// A struct to serialize and deserialize NBT data.
pub struct Nbt<'de, T>(PhantomData<&'de T>, pub T) where T: Serialize + Deserialize<'de>;
struct NbtVisitor<'de, T>(PhantomData<&'de T>) where T: Deserialize<'de>;

/// A struct serializing to a length prefixed [`Vec`] of `T`s.
pub struct LengthPrefixedVec<'de, T>(PhantomData<&'de T>, pub Vec<T>) where T: Serialize + Deserialize<'de>;

impl LevelType {
    /// used to convert enum value to String
    pub fn to_string(&self) -> String {
        match self {
            Self::Default => String::from("default"),
            Self::Flat => String::from("flat"),
            Self::LargeBiomes => String::from("largeBiomes"),
            Self::Amplified => String::from("amplified"),
            Self::Customized => String::from("customized"),
            Self::Buffet => String::from("buffet"),
            Self::Default11 => String::from("default_1_1"),
        }
    }
}

impl<'de, T: Serialize + Deserialize<'de>> Serialize for Nbt<'de, T> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer {
            let mut bytes = vec![];

            let mut encoder = Encoder::new(&mut bytes, None);
            self.0.serialize(&mut encoder).unwrap();

            bytes.serialize(serializer)
    }
}

impl<'de, T: Serialize + Deserialize<'de>> Deserialize<'de> for Nbt<'de, T> {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de> {
            deserializer.deserialize_seq(NbtVisitor(PhantomData))
    }
}

impl<'de, T: Serialize + Deserialize<'de>> Visitor<'de> for NbtVisitor<'de, T> {
    type Value = Nbt<'de, T>;

    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        formatter.write_str("expected seq")
    }

    fn visit_seq<A>(self, seq: A) -> Result<Self::Value, A::Error>
    where
        A: serde::de::SeqAccess<'de>,
    {
        let mut decoder = Decoder::new(SeqReader(PhantomData, seq));

        Ok(Nbt(PhantomData, T::deserialize(&mut decoder)))
    }
}

struct SeqReader<'de, A: SeqAccess<'de>>(PhantomData<&'de A>, pub A);

impl<'de, A: SeqAccess<'de>> Read for SeqReader<'de, A> {
    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
        for b in buf.iter_mut() {
            *b = self.1.next_element().map_err(|e| Error::new(ErrorKind::Other, format!("{}", e)))?.ok_or(Error::new(ErrorKind::UnexpectedEof, ""))?;
        }

        Ok(buf.len())
    }
}
